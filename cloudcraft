#!/usr/bin/env python
from ConfigParser import ConfigParser
from optparse import OptionParser

import logging
import subprocess
import os
import errno
import json

import craft

log = logging.getLogger("cloudcraft")

# http://stackoverflow.com/a/600612
def mkdir_p(path):
    try:
        os.makedirs(path)
    except OSError as exc: # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else: raise


def initialize(cloudcraft_home, config):
    # Error out if we find a file of the same name?
    mkdir_p(cloudcraft_home)
    mkdir_p(os.path.join(cloudcraft_home, "instances"))
    mkdir_p(os.path.join(cloudcraft_home, "keys"))
    config_template = "etc/config.template"
    if not os.path.exists(config):
        log.warning("{0} not found.".format(config))
        print
        print "Initalizing cloudcraft configuration at {0}".format(config)
        print "Cloudcraft needs your AWS keys to run"
        print "This can be accessed from https://portal.aws.amazon.com/gp/aws/securityCredentials#access_credentials"
        token, secret = "", ""
        try:
            while (token.strip() == ""):
                token = raw_input("AWS access key: ")
            while (secret.strip() == ""):
                secret = raw_input("AWS access secret: ")
            print
            print "Validating the AWS keys"
            api = craft.aws.AWS(token, secret)
            api.conn.get_all_instances()
        except EOFError, KeyboardInterrupt:
            print "Bye!"
        except:
            log.error("API Key validation failed! Config file was not written.")
            exit(-1)
        f = open(config_template).read()
        with open(config, "w") as c:
            c.write(f.format(token=token, secret=secret))
        print "Wrote config at {0}. Run the same command once again to continue.".format(config)
        exit(0)



# FIXME: Heavy refactor needed
def despatch(options, args):
    """Despatches commands."""
    conf = ConfigParser()
    conf.read(options.config)

    cloudcraft_home = options.cloudcraft_home

    token = conf.get("amazon", "AWS_ACCESS_TOKEN")
    secret = conf.get("amazon", "AWS_ACCESS_SECRET")
    region = conf.get("amazon", "EC2_REGION")
    instance_type = conf.get("amazon", "INSTANCE_TYPE")
    security_group = conf.get("amazon", "SECURITY_GROUP", "cloudcraft")
    ami = conf.get("amazon", "AMI")
    user = "ubuntu"

    key_name = "cloudcraft-{0}".format(region)
    key_path = os.path.join(cloudcraft_home, "keys")

    aws_api = craft.aws.AWS(token, secret, region=region)
    command = args[0]
    mcserver_name = args[1]
    command_args = args[2:]

    metadata_path = os.path.join(cloudcraft_home, "instances", mcserver_name)
    mcs = craft.mcserver.load_server(metadata_path)

    if command == "spawn":
        if mcs:
            log.error("{0} already exists.".format(mcserver_name))
            exit(-1)
        else:
            key = aws_api.sync_keypair(key_name, key_path)
            aws_api.sync_security_group(security_group)
            mcs = aws_api.spawn(mcserver_name, ami=ami, instance_type=instance_type,
                                key_name=key_name, security_group=security_group,
                                user=user)
            if mcs:
                log.info("Instance {0} is up and running.".format(mcs.name))
                craft.mcserver.save_server(mcs, metadata_path)
            else:
                log.error("Couldn't spawn instance {0}".format(mcs.name))
                exit(-1)
    elif command in ["destroy", "reboot", "boot", "shutdown", "info"]:
        if not mcs:
            log.error("Instance {0} doesn't exist".format(mcserver_name))
            exit(-1)
        getattr(aws_api, command)(mcs)
        if command == "destroy":
            log.debug("Deleting instance metadata")
            os.remove(metadata_path)

    else:
        if not mcs:
            parser.error("Invalid instance")
        ec2_instance = aws_api.get_instance(mcs.server_id)
        remote_vars = dict(conf.items("minecraft"))
        if ec2_instance.state != "running":
            log.error("Instance {0} is not running. If you had run 'boot' recently, give it a couple of minutes for {0} to boot up.".format(mcs.name))
            exit(-1)
        key_file = os.path.join(key_path, "{0}.pem".format(key_name))
        if command == "setup":
            command = ["bootstrap", "fetch", "start"]
        mcs.run_command(ec2_instance.public_dns_name,
                        command, key_file, remote_vars=remote_vars,
                        command_args=command_args)
    return True


def get_arg_parser():
    usage = "usage: %prog [options] [spawn|destroy|setup server_name] [list [server_name]]"
    cloudcraft_home = os.path.join(os.path.expanduser("~"), ".cloudcraft")
    if os.environ.get("CLOUDCRAFT_HOME"):
        cloudcraft_home = os.environ["CLOUDCRAFT_HOME"]
    log.debug("Setting CLOUDCRAFT_HOME to {0}".format(cloudcraft_home))
    cloudcraft_config = os.path.join(cloudcraft_home, "cloudcraft.conf")

    parser = OptionParser(usage=usage)
    parser.add_option("-H", "--home", dest="cloudcraft_home", default=cloudcraft_home,
                      help="cloudcraft config file")
    parser.add_option("-c", "--config", dest="config", default=cloudcraft_config,
                      help="cloudcraft config file", metavar="FILE")
    parser.add_option("-l", "--log", dest="log", default="INFO",
                      help="Log level. Use DEBUG for verbose output")
    return parser


def get_logger(level):
    lvl = getattr(logging, level.upper(), logging.INFO)
    if not isinstance(lvl, int):
        raise ValueError('Invalid log level: %s' % level)
    logging.basicConfig(format="%(levelname)s: %(message)s")
    log.setLevel(lvl)
    return log


if __name__ == '__main__':
    parser = get_arg_parser()
    (options, args) = parser.parse_args()
    get_logger(options.log)

    initialize(options.cloudcraft_home, options.config)

    if not despatch(options, args):
        parser.print_usage()
