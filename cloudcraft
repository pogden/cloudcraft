#!/usr/bin/env python
from ConfigParser import ConfigParser
from optparse import OptionParser

import subprocess
import os
import errno
import json
import fabric.context_managers as ctxt

import craft

from fabric.colors import green, red
from fabric.tasks import execute


# http://stackoverflow.com/a/600612
def mkdir_p(path):
    try:
        os.makedirs(path)
    except OSError as exc: # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else: raise


def initialize(cloudcraft_home):
    # Error out if we find a file of the same name?
    mkdir_p(cloudcraft_home)
    mkdir_p(os.path.join(cloudcraft_home, "instances"))
    mkdir_p(os.path.join(cloudcraft_home, "keys"))


# FIXME: Heavy refactor needed
def despatch(options, args):
    """Despatches commands."""
    conf = ConfigParser()
    conf.read(options.config)
    # FIXME:
    # only list doesn't require the second 'arg'. Everyone else needs the
    # instance name as one of the args. Maybe this can be done in a much
    # cleaner manner
    if len(args) < 2 and args[0] != "list":
        return False
    instance_file = None
    instance_name = "" if len(args) == 1 else args[1]
    instance = {}
    try:
        if instance_name:
            instance_file = os.path.join(options.cloudcraft_home, "instances", instance_name)
            instance = json.load(open(instance_file))
    except IOError:
        pass

    if args[0] == "spawn":
        if instance:
            print "{0} already exists".format(instance_name)
            exit(-1)
        instance = craft.aws.provision(options.cloudcraft_home, instance_name,
                                       **dict(conf.items("amazon")))
        if not instance:
            print "Spawning failed!"
        json.dump(instance, open(instance_file, "w"), indent=True)
        print "Instance is running."
    elif args[0] == "destroy":
        if not instance:
            print "Couldn't load instance"
            exit(-1)
        token = conf.get("amazon", "AWS_ACCESS_TOKEN")
        secret = conf.get("amazon", "AWS_ACCESS_SECRET")
        region = conf.get("amazon", "EC2_REGION")
        stat = craft.aws.destroy(instance, aws_access_token=token,
                                 aws_access_secret=secret, ec2_region=region)
        if stat:
            print "Deleting instance metadata"
            os.remove(instance_file)
    elif args[0] == "list":
        if instance_name and not instance:
            parser.error("Invalid instance")
        elif instance: # Not my proudest piece of code
            print "\n".join(["{0}: {1}".format(k,v) for k,v in instance.items()])
        else:
            print "\n".join(os.listdir(os.path.join(options.cloudcraft_home,
                                                    "instances")))
    else:
        if not instance:
            parser.error("Invalid instance")

        sh_args = args[1:] if len(args) >= 2 else []
        command = args[0]
        keyname = instance["keyname"]
        keyfile = os.path.join(cloudcraft_home, "keys", "{0}.pem".format(keyname))
        user = conf.get("ami_users", instance["image_id"])
        remote_vars = dict(conf.items("minecraft"))

        with ctxt.settings(
            host_string="%s@%s" %(user, instance["public_dns_name"]),
            key_filename=keyfile,
            prefix=""):
            with ctxt.hide("running"):
                # Because this is ami specific instead of instance specific
                if command == "bootstrap":
                    try:
                        res = execute(craft.commander.bootstrap_server, instance["image_id"])
                    except:
                        import traceback
                        print traceback.format_exc()
                elif command in ["sh", "shell"]:
                    print(green("Logging in as '%s'" % user))
                    subprocess.call(["ssh", "-i", keyfile, "%s@%s" % (user, instance["public_dns_name"])])
                else:
                    print(green("Doing '{0}' for '{1}'".format(command, instance_name)))
                    res = execute(craft.commander.run_remote, command, command_args=sh_args,
                                  remote_vars=remote_vars)




    return True


def get_arg_parser():
    usage = "usage: %prog [options] <provision|destroy> <name>"
    parser = OptionParser(usage=usage)
    parser.add_option("-c", "--config", dest="config", default="craft.conf",
                      help="cloudcraft config file", metavar="FILE")
    return parser


if __name__ == '__main__':
    parser = get_arg_parser()
    (options, args) = parser.parse_args()

    cloudcraft_home = os.path.join(os.path.expanduser("~"), ".cloudcraft")
    if os.environ.get("CLOUDCRAFT_HOME"):
        cloudcraft_home = os.environ["CLOUDCRAFT_HOME"]
    initialize(cloudcraft_home)

    options.cloudcraft_home = cloudcraft_home
    if not despatch(options, args):
        parser.print_usage()
