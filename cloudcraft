#!/usr/bin/env python
from ConfigParser import ConfigParser
from optparse import OptionParser

import logging
import subprocess
import os
import errno
import json
import fabric.context_managers as ctxt

import craft

from fabric.colors import green, red
from fabric.tasks import execute

log = logging.getLogger("cloudcraft")

# http://stackoverflow.com/a/600612
def mkdir_p(path):
    try:
        os.makedirs(path)
    except OSError as exc: # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else: raise


def initialize(cloudcraft_home):
    # Error out if we find a file of the same name?
    mkdir_p(cloudcraft_home)
    mkdir_p(os.path.join(cloudcraft_home, "instances"))
    mkdir_p(os.path.join(cloudcraft_home, "keys"))


# FIXME: Heavy refactor needed
def despatch(options, args):
    """Despatches commands."""
    conf = ConfigParser()
    conf.read(options.config)
    # FIXME:
    # only list doesn't require the second 'arg'. Everyone else needs the
    # instance name as one of the args. Maybe this can be done in a much
    # cleaner manner
    if len(args) < 2 and args[0] != "list":
        return False
    instance_file = None
    instance_name = "" if len(args) == 1 else args[1]
    instance = {}
    try:
        if instance_name:
            instance_file = os.path.join(options.cloudcraft_home, "instances", instance_name)
            instance = json.load(open(instance_file))
    except IOError:
        pass

    if args[0] == "spawn":
        if instance:
            log.error("{0} already exists".format(instance_name))
            exit(-1)
        instance = craft.aws.provision(options.cloudcraft_home, instance_name,
                                       **dict(conf.items("amazon")))
        if not instance:
            log.error("Spawning failed!")
        json.dump(instance, open(instance_file, "w"), indent=True)
        log.info("Instance {0} is up and running. Run 'setup' to install minecraft server".format(instance_name))
    elif args[0] == "destroy":
        if not instance:
            log.error("Instance {0} doesn't exist".format(instance_name))
            exit(-1)
        token = conf.get("amazon", "AWS_ACCESS_TOKEN")
        secret = conf.get("amazon", "AWS_ACCESS_SECRET")
        region = conf.get("amazon", "EC2_REGION")
        stat = craft.aws.destroy(instance, aws_access_token=token,
                                 aws_access_secret=secret, ec2_region=region)
        if stat:
            log.debug("Deleting instance metadata")
            os.remove(instance_file)
    elif args[0] == "list":
        if instance_name and not instance:
            parser.error("Instance {0} doesn't exist".format(instance_name))
        elif instance: # Not my proudest piece of code
            print "\n".join(["{0}: {1}".format(k,v) for k,v in instance.items()])
        else:
            print "\n".join(os.listdir(os.path.join(options.cloudcraft_home,
                                                    "instances")))
    else:
        if not instance:
            parser.error("Invalid instance")

        command = args[0]
        commands = ["bootstrap", "fetch", "start"] if command == "setup" else [command]
        sh_args = args[1:] if len(args) >= 2 else []
        keyname = instance["keyname"]
        keyfile = os.path.join(cloudcraft_home, "keys", "{0}.pem".format(keyname))
        user = conf.get("ami_users", instance["image_id"])
        remote_vars = dict(conf.items("minecraft"))

        with ctxt.settings(
            host_string="%s@%s" %(user, instance["public_dns_name"]),
            key_filename=keyfile,
            output_prefix=False,
            prefix=""):
            with ctxt.hide("running", "aborts"):
                for cmd in commands:
                    # Because this is ami specific instead of instance specific
                    if cmd == "bootstrap":
                        res = execute(craft.commander.bootstrap_server, instance["image_id"])
                    elif cmd in ["sh", "shell"]:
                        print(green("Logging in as '%s'" % user))
                        subprocess.call(["ssh", "-i", keyfile, "%s@%s" % (user, instance["public_dns_name"])])
                    else:
                        print(green("Running '{0}' for '{1}'".format(cmd, instance_name)))

                        res = execute(craft.commander.run_remote, cmd, command_args=sh_args,
                                      remote_vars=remote_vars)
    return True


def get_arg_parser():
    usage = "usage: %prog [options] [spawn|destroy|setup server_name] [list [server_name]]"
    parser = OptionParser(usage=usage)
    parser.add_option("-c", "--config", dest="config", default="craft.conf",
                      help="cloudcraft config file", metavar="FILE")
    parser.add_option("-l", "--log", dest="log", default="INFO",
                      help="Log level. Use DEBUG for verbose output")

    return parser


def get_logger(level):
    lvl = getattr(logging, level.upper(), logging.INFO)
    if not isinstance(lvl, int):
        raise ValueError('Invalid log level: %s' % level)
    logging.basicConfig(format="%(levelname)s: %(message)s")
    log.setLevel(lvl)
    return log


if __name__ == '__main__':
    parser = get_arg_parser()
    (options, args) = parser.parse_args()

    get_logger(options.log)
    
    cloudcraft_home = os.path.join(os.path.expanduser("~"), ".cloudcraft")
    if os.environ.get("CLOUDCRAFT_HOME"):
        cloudcraft_home = os.environ["CLOUDCRAFT_HOME"]
    log.debug("Setting CLOUDCRAFT_HOME to {0}".format(cloudcraft_home))
    initialize(cloudcraft_home)
        
    options.cloudcraft_home = cloudcraft_home
    if not despatch(options, args):
        parser.print_usage()
